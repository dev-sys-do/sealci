# Scheduler technical documentation

## Dependencies

This microservice uses Tonic. Tonic makes use of Prost. [...]

## Commands

Starting the Scheduler server

```bash
cargo run --bin server
```

Testing Agent registration

```bash
cargo run --bin client_register_agent
```

> Note: to build the server with optimizations: `cargo build --release --bin server`

## File structure and modules

Explanations of the Scheduler implementation architecture.

### .gitignore

Contains

```.gitignore
/target
```

As to not commit compiled binaries, dependencies, and other artifacts into version control.

### target/

This directory is created by `cargo` during `cargo run`
Cargo is Rust's build system and package manager.
*It does not appear if you have not run the project*

> Tip: you can use `cargo clean` to clean remove artifacts generated by cargo from the target directory.

### Cargo.lock

This file contains the state of resolved dependencies. It is generated automatically.

### Cargo.toml

This file describes our dependencies, and our binary targets.
The binary targets are the programs we can run.
If you try to execute `cargo run`, the following (or similar) will display:

```bash
$ cargo run
error: `cargo run` could not determine which binary to run. Use the `--bin` option to specify a binary, or the `default-run` manifest key.
available binaries: client_RegisterAgent, server
```

It shows the available target binaries to run. You can run them with `cargo run --bin <name_of_bin>`.

### build.rs

This script is compiled and executed by Cargo before building the package.
Notably, we point to the .proto files in this script.

### src/main.rs

This file contains the server.
It calls the code generated by Tonic from the .proto, as well as the code for the gRPC `interfaces/`.

### src/tests/

Contains mocks to test the gRPC interfaces.
You can run the code within with `cargo run --bin <name_of_binary_target>`
> /!\ `cargo run --bin server` starts the Scheduler server service. Not a mock nor a test.

### src/proto/

This directory contains the module definition that makes the code generated from the gRPC protos easier to import and use in other submodules.

### src/interfaces/

Contains the gRPC interfaces implementation.
That is, handling requests, responses, streams...
There is no scheduler logic within that source code, only gRPC implementations, gRPC errors handling.

The only context known by this code is gRPC.
As such, this code should not handle any other errors than gRPC errors.

This code calls the Scheduler logic implementation defined in `src/logic/*`
All context relative to the Scheduler logic implementation (such as inputs from gRPC requests) is passed down to this code.

### src/logic/

Contains the Scheduler logic implementation.

The only context known by this code is the Scheduler logic. That is its procedures, data structures...
As such, this code should be handling only errors relative to the Scheduler implementation.

This code is called by the gRPC interfaces implementation defined in `src/interfaces/*`
